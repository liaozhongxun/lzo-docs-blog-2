---
title: 正则表达式
---

## regexp

### 作用

-   数据隐藏(`180****9356`)
-   数据采集(爬虫)
-   数据过滤(`你是****`)
-   数据验证(手机好，网址...)

### JS 正则方法

-   创建正则
    -   `var reg = /^xxx/ig`：字面量方式
    -   `var reg = new RegExp("^xxx","ig")`：构造行数创建
    -   第一中正则在编译时就创建，实例的正则在运行是才创建
-   匹配模式(修饰符)
    -   表示正则的附加规则，放在最后面
    -   `i:ignore` 忽略大小写
    -   `g:global` 全局匹配，匹配字符串中所有匹配的词
-   JS 正则对象提供的方法
    -   `reg.test("str");`:test 验证 str 中是否存在符合规则的子字符串
    -   `reg.test(["str1","str2","strn"])`:只要一个符合条件就返回true
    -   `reg.exec("str");`:exec 返回 str 中，匹配到的符合规则的第一个子字符串,与`小括号包裹`的子表达式，不匹配返回`null`
    
-   String 方法提供的方法
    -   `str.search(reg)`:从 str 中查找 reg 匹配到子字符串的`起始位置`,没有返回`-1`
    -   `str.match(reg)`:以数组模式返回 str 中所以符合 reg 要求的子字符串,和正则的`exec`类似,并通过 g 获取所以匹配项
    -   `str.replace(reg，callback|char)`:把匹配到的子字符串进行替换
        -   callback参数
            -   如果没有子表达式，参数二是匹配字符串起始位置
                -   callback((每次匹配,小括号1，index)=>{xxx})
            -   如果存在子表达式，参数是，匹配字符串、子1、子n、匹配字符串起始位置
                -   callback((每次匹配,小括号1，小括号n,index)=>{xxx})
        -   "12liao34zhong56xun".replace(/([a-zA-Z]+)/g,(item)=> item.substring(0,1).toUpperCase()+item.substring(1))
    -   `str.replaceAll(reg，callback|char)`
        -   正则reg必须加g全局匹配
    -   `str.split(reg)`:通过 str 中 reg 匹配到的子字符串进行分割(默认 g)

### 重要概念

-   字表达式\
    -   通过小括号括起来的内容称`字表达式`
-   捕获
    -   字表达式匹配到内容时，系统会捕获这个行为，然后将字表达式匹配到的内容放到缓存区中，成为`捕获`
    -   第一个捕获编号 1,等 n 个编号 n
-   反向引用
    -   通过\n(n>0 的，代表缓存区编号)来获取缓存区域的内容
    -   在表达式中使用已近查到的结果
-   经典案例(str = "abc22333444")
    -   找到至少连续的三位相同数字
        -   `/(\d)\1\1/g`:(\d)捕获，通过反向拿到缓存区 1 中的内容

### 小阔号的功能
查询处符合条件的字符串，只要一个符合条件则反 true,判断全部 => (?\<!xxx) 只要一个不符合条件返回true,所有不符合返回false

-   ():默认捕获效果，可通过\n 反向引用匹配的值
-   (?:xxx):非捕获匹配，不会影响\n
-   (?=xxx):非捕获匹配，`正向肯定预查`,相当与添加条件限制`/^(?=.*8060$)xxxx`,表达式必须以 8060 结尾
    -   `/hello(?=\d{3})/.exec("hello123")`:hello 后面必须是三个数字
    -   我要提取的只是 hello,但是这个 hello 后面必须跟着 3 个数字
-   (?!xxx):非捕获匹配,`正向否定预查`,相当于添加条件限制`/^(?!.*8060$)xxxx`,表达式不能以 8060 结尾
    -   `/\d{4}(?![a-zA-Z])/exec("3243##")`:数字后面不能出现字母
-   (?\<=xxx):非捕获匹配,`反向肯定预查`,相当于添加条件限制（先找到四个字母，再看看四个字母左边是否出现三个数字 ）
    -   `/(?<=\d{3})[a-zA-Z]{4}/.exec("123fdsf")`:连续 4 个字母左边必须出现 3 个数字
    -   先确定字符串中有 3 个连续数字，找到了，再看后面的字符是否匹配
-   (?\<!xxx):非捕获匹配,`反向否定预查`,相当于添加条件限制
    -   `/(?<!\d{3})[a-zA-Z]{4}/.exec("123fdsf")`:连续 4 个字母左边不能是 3 个数字
    -   字符串中只要1个连续 4 个字母左边不是3个数字,就返回true,全部都不是返回false
        -   是否全部str|max前面都是$
            -   `!/(?<!\$)(str|max)/.test("xx$strxx$maxxxx$strxxx$max")`

```javascript
// 前瞻：
exp1(?=exp2) 查找exp2前面的exp1
// 后顾：
(?<=exp2)exp1 查找exp2后面的exp1
// 负前瞻：
exp1(?!exp2) 查找后面不是exp2的exp1
// 负后顾：
(?<!exp2)exp1 查找前面不是exp2的exp1
```
### 编写规则

> 正则表达式是由所有字符以及特殊字符(元字符组成)的`文字模式`
> 正则表达式作为一个模板，将`文字模式`与搜索到的字符串进行匹配

#### 查什么(匹配符)

-   需要什么字符就填什么字符，元字符就前面加反斜杠\
-   js 可以直接匹配具体汉字，有些语言是不可以的
-   字符簇
    -   [a-zA-Z0-9]
        -   [ASCII]从上到下的顺序都可以如：[Z-a]可以匹配 Z、、\[、\],^,-,\`、a 等字符
    -   [abc]: 匹配A或B或C
    -   [^abc]: 取反，就不匹配 A、B、C
    -   [\u4e00-\u9fa5]: 匹配中文
-   `\d`:匹配纯数字，`\D`取反
-   `\w`:数字字母下划线，`\W`取反
-   `\s`:任意空白字符,`\S`取反，非空白字符
-   `.`:匹配处理回车`\n`外任意单个字符

#### 差多少(限定符)

-   `*`:匹配前面次数 0 次或多次{0,},`.*`任意多次任意字符
-   `+`:匹配前面次数 1 次或多次{1,}
-   `?`:匹配前面次数 0 次或 1 次
-   `{n}`:n 次
-   `{n,}`:至少 n 次
-   `{n,m}`:n 次到 m 次

#### 从哪差(定位符)

-   `^`:`[]`外，匹配字符串开始位置
-   `$`:匹配字符串结束位置
-   `\b`:匹配单词边界
    -   `/\b\zhong\b/.test("liao zhong 123")`:匹配字符串中是否有 zhong，并且是单词
-   `\B`:匹配非单词边界
    -   `/\B\zhong\B/.test("liaozhong123")`:匹配字符串中是否有 zhong，并且是不能是单词

#### 其他

-   `\`:反斜杠，转义使特殊字符变成普通字符，`\.`这里的.只能代表.
-   `|`:或，(a|b|c)

### linux 正则 与 通配符

> linux 指令中一百操作文件路径的用`通配符`,如:find，ls，cp 等,操作文件内容的用`正则`,如 grep

#### 通配符

-   `*`：匹配零或多个任意字符
-   `?`:匹配任意单个字符
-   `[]`：指定中括号内的多个字符，如：[rwc]或[r,w,c]都行
-   `[^]或[!]`：除了中括号内字符外匹配任一个字符
-   `{a,b,c}/{a..z}`:a 或 b 或 c / a 到 z

#### linux 正则

-   与通配符差别

    -   `*`：匹配前面的字符零次或多次
    -   `.`：匹配任意一个字符
    -   `?`：前面的字符零次或一次，基本正则是?
    -   `+`：前面的字符至少一次，基本正则是+
    -   `[]`：和通配符完全一样
    -   `[^]`：和通配符一样，但是没有[!]的写法
    -   `^h、$h、\<h、h\>`:行头 h、行尾 h、h 开头的单词、h 结束的单词

-   默认正则
    -   特殊含义字符`默认没有功能`,加上`\`才是功能元字符
    -   ？、+、{}、()、、、需要反斜杠\，
        -   `ro\?t`(r 开头 t 结尾，o 可有可无)
        -   `ro\+t`(r 开头 t 结尾，o 至少一次，root、rot)
-   扩展正则
    -   把有特殊含义的符号，`默认拥有功能`，如果要匹配字符要加上`\`转义
    -   各个命令开启方式
        -   grep: 一般 `-E参数` 或 egrep 开启扩展正则
    -   扩展正则新增操作
        -   grep -E "reg1|reg2"
-   其他
    -   `=~`:判断变量是否符合正则(`num=10;[[ $num =~ [0-9]{2} ]]`)

### 案例

-   判断回文字符串

```javascript
function huiwenVis(str) {
    //判断是否回文字符串，通过反向引用\n判断最后一个是否为第一个字符，中间类推
    const arr = Array.from({ length: Math.floor(str.length / 2) });
    const regExpStr = arr
        .fill("(.)")
        .concat(str.length % 2 ? ["."] : [])
        .concat(arr.map((_, index) => `\\${arr.length - index}`))
        .join("");

    return new RegExp(`^${regExpStr}$`).test(str);
}

console.log(huiwenVis("abccba"));

//其他方法: x.toString() === x.toString().split('').reverse().join('')
```

-   ip 端口地址验证
-   解析 rul

```javascript
let urls = "https://www.baidu.com?a=1&b=2";
let q = {};
urls.replace(/([^?&=]+)=([^&]+)/g, (_, k, v) => (q[k] = v));
console.log(q);
```
-   数字分割
```javascript
//(?!$) 不能是最后一位
'1234567890'.replace(/\d{3}(?!$)/g,(a)=>a+",")

// (?=(p)) 匹配找到 符合p子模式 前面的 那个位置
console.log('18060849356'.replace(/(?=(\d{4})+$)/g,'-'));
console.log('18060849356'.replace(/(?!^)(?=(\d{3})+$)/g,'-'));
```

-   去除字符串中多出指定规则的内容

```javascript
//同时去除字符串前两位与后四位
'12werty5678'.replace(/^\w{2}|\w{4}$/g,"")
```

-   车牌号规则

```javascript
const carNoReg = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/
```
- 判断单词是否由其他指定字符串组成
```javascript
/^(hello|word|add){1,}$/.test('helloword');
```

- split

```javascript

// 不保留符号
"split>=1xx<=2xx&&3xx".split(/>=|<=|&&/) // ['split', '1xx', '2xx', '3xx']
// 保留符号
"split>=1xx<=2xx&&3xx".split(/(>=|<=|&&){1}/) // ['split', '>=', '1xx', '<=', '2xx', '&&', '3xx']
// 优先级
"split>=111=222>=333".split(/(>=|=){1}/) //['split', '>=', '111', '=', '222', '>=', '333']
```

- 范围
    -   (Unicode官网)[https://www.52unicode.com/]
    -   Unicode-中文 [\u4e00-\u9fa5] 专注于简体 (Unicode 汉字)[https://www.52unicode.com/cjk-unified-ideographs-zifu]
        -   经测试 [\u4e00-\u9fe6] 都是汉字 => 9fa5龥 、9fa6龦
        -   经测试 [\u9fe7-\u9FFF] 都是空白 
        -   所以说 [\u4e00-\u9FFF] 验证中文都是可以的
    -   十六进制-0到255 [\x00-\xFF]  => str.replace(/[^\x00-\xFF]/g,'**').length; 字符串字节长度