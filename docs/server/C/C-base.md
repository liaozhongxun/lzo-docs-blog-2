---
title: C
---

## 概念

-   语言过程
    -   二进制语言 0101->汇编语言(助记符)-> B 语言 -> C 语言 -> C++...高级语言
-   c 语言发展中个开发厂商的 C 语言产生差异，美国国家标准局定制标准语法`ANSIC`
    -   11 年国际标准组织`ISO`和国际电工委员会`IEC`发布最新标准`C11`
    -   主要编译器`GCC`、`MSVC`、Clang、WIN-TC、SUBLIME、Turbo C 等
-   C 语言优点
    -   基础性语言
    -   语法简洁紧凑方便灵活
    -   运算符数据结构丰富
    -   结构化，模块化编程
    -   移植性好，执行效率高
    -   允许直接操作硬件

## 语法

### 基本要求

-   注意
    -   头文件正确包含的重要性
    -   以函数为单位进行编程
    -   程序包括`声明部分`+`实现部分`
    -   main return 的值是给它父进程看的($?状态码)
    -   多用空格与换行
    -   注释 /星星/
        -   #if 0 换行 xxx 换行 xx #endif
-   算法:解决问题的方法(流程图,NS 图，有限状态机 FSM 等显示出来)
-   程序：用某种语言实现算法
-   进程:
-   防止写越界、防止内存泄露、谁打开谁关闭、谁申请谁释放

### 数据类型、运算符、表达式

#### 数据类型

-   类型转换
    -   a (int)b;
-   数据类型

    -   基本数据类型

        -   数值类型

            -   整型

                -   短整型`short`
                -   整型`int`
                -   长整型`long`
                -   三种还区分有符号(默认)和无符号，同样占 32 位的有符号整型，最高位代表 0 正 1 负
                    -   范围不同，表示的大小是一样的，-128 和+127 间个数 等于 0 到 255 的个数

            -   浮点型
                -   单精度`flat`
                -   双精度`double`
                -   科学技术法:3e-23 ，3 乘以 10 的负 23 次方

        -   字符类型`char`
        -   布尔`bool`（需要引入头文件 stdbool.h）

    -   构造类型
        -   数组
        -   结构体
        -   公用体
        -   枚举类型
    -   指针类型
    -   空类型`void`

-   重点

    -   所占字节
        -   数据类型所占字节随着机器的不同而不同。
    -   储存区别
    -   不同数据类型的转化
        -   显式(手动，强制类型转化)
        -   隐式
    -   特殊性

        -   bool 需要引入头文件
        -   float 类型的比较，不能和一个确切的值相比,是一个大概范围的表示，
        -   chat 类型是否有符号，不确定
        -   不同形式的 0 值`0 '0' "0" '\0'`
        -   数据类型与后续代码的输入输出相匹配

        -   字符转义字符
            -   '\567' :斜杠后三位当做八进制来看
            -   '\x9f' :\x 开头当做十六进制看

#### 变量与常量

-   变量(值随时变化的量)

    -   格式:[存储类型] 数据类型 标识符 = 值;

        -   标识符：数字字母下划线组成的序列，数字不能开头
        -   数据类型:基础+构造+...所有数据类型
        -   值:类型与值匹配
        -   储存类型

            -   auto:默认(储存栈中)
                -   空间自动分配，自动释放，自动回收，不需要我们操作空间
            -   static:静态类型

                -   没有赋值一定会自动初始化为 0 或 null
                -   变量的值有继承性质,如：函数中的 static 变量，函数调用多次，这个变量是共用的,只分配一块空间
                -   修饰全局变量后，不会音响到其他文件中同名的全局变量
                -   修饰函数后,该函数不能在其他.c 文件中使用

            -   register:寄存器类型(建议编译器将变量存储位置在寄存器上)
                -   寄存器存在 CPU 中，将变量直接声明在 CPU 中速度快，但资源少
                -   是否能成功由 gcc 判断，条件如下
                    -   只能是局部变量
                    -   大小限制，32 位的环境下只能，寄存变量只能是<=32 位的
                    -   寄存器中没有地址，寄存器类型变量无法打印或查看地址
            -   extern:说明型
                -   不是定义变量，不能更改被说明的变量和类型
                -   extern int i;在该文件中是使用到的 i 不是自动定义的，去用其他文件定义的

    -   声明周期
    -   作用范围
        -   全局和局部
            -   内部作用域优先级大于外面作用域
        -   全局变量
            -   作用范围:从定义开始到程序执行结束
        -   局部变量
            -   作用范围:从定义开始到当前大括号块结束
            -   函数中的变量
            -   修饰符不同代表的局部变量用法也不一样

-   常量(程序执行过程中值不会发生变化的量)
    -   整型常量 1，33，44
    -   实型常量 2.33,4.555
    -   字符常量 由单引号引起来的单个字符或转义字符'a','\t'
    -   字符串常量 由双引号引起的一个过多个字符序列
    -   标识常量 #define PI 3.14(#define 宏名 宏体);编写使用宏名，预处理后`完全替换`宏体,不校验
        -   带参数：#define MAX(a,b) a>b?a:b
        -   带参数：#define MAX(a++,b++) a>b?a:b;替换后:a++>b++?a++:b++
        -   处理问题：#define MAX(a++,b++) ({int A=a,B=b; A>B?A:B;});替换后:a++>b++?a++:b++
        -   宏的运行:在程序预处理接口执行，不占用运行时间，占用编译时间，一改全改
        -   对比函数:作用类似，安全性低，效率更高（对比宏，函数接收到变量直接进行运算）

#### 运算符

-   运算符

    -   算术运算符(+, -, \*, /, %, ++, --)
        -   `+|-` 单目的画是正负
        -   `%`:取余两边必须是整数
        -   `/`:被除数(分母或右边的)不能是 0
        -   自增自减:元算法在前，先进行计算再取变量使用，否则先用，之后再计算
    -   关系运算符(< <= == >= > !=)
    -   逻辑运算符(! && ||)
        -   短路特性:&& 左边为假，不会走右边表达式; || 左边为真，不会走右边表达式
    -   位运算符(<< >> ~ | ^ &)
        -   << 左移(相当于乘 2)
            -   二进制向左移动一位，右边补上一个 0
            -   B1100 -> B0001 1000
        -   \>\> 右移(相当于除 2)
            -   二进制向右移动一位，右边去掉一个 0
            -   B1100 -> B0110
        -   ~ 取反
            -   不考虑符号位，二进制 1 变 0，0 变 1
            -   B1100 -> B0011
        -   | 按位或
            -   两个二进制操作数，同位置一边为 1 就为 1，两边为 0 才为 0
            -   B1100 | B1010 => B1110
        -   & 安位与
            -   两个二进制操作数, 同位置一边为 0 就为 0，两边为 1 才为 1
            -   B1100 | B1010 => B1000
        -   ^ 按为异或
            -   连个二进制操作数，相同为 0，不同为 1
            -   B1100 ^ B1010 => B0110
        -   理解
    -   赋值运算符（=）
        -   +=，-=，\*=，/=
    -   条件运算符(三目运算 ？：)
    -   逗号运算符（都会 主要运用连续定义变量）
    -   指针运算符(星号 A,获取地址 &B, int 星 A = &B)
        `int *p = &j`
    -   求字节数(sizeof(int),sizeof(xxx))
    -   强制转换类型 a = (int)b
        -   转换只是一个过程，并不会改变 b 的值
    -   分量运算符
    -   下标运算符
    -   其他

-   结合性
-   优先级
-   运算符的特殊用法
-   为运算的重要意义

#### 表达式

### 输入输出专题

-   格式化输入输出函数 scanf、printf

    -   printf
        -   int printf(const char \*format,...)
            -   format:"%[可选修饰符]格式字符，替换逗号后面的变量"
                -   变量什么类型，建议用响应的格式字符输出，需要匹配
                -   格式字符
                    -   d,i:十进制整型数
                    -   x,o:将值通过十六，八进制无符号整数输出
                    -   u:无符号十进制整型
                    -   c:单一字符
                    -   s:字符串
                    -   f:浮点小数
                    -   e:将输出的值通过指数形式科学计数法输出
                -   修饰符
                    -   m|.n
                        -   整数 j:设置输出宽带，比实际小忽略，否则前面补空格，printf("i = %4d",i)
                        -   浮点数:%8,1f,指定输出需要 8 位，小数点保留一位四舍五入
                        -   字符串:%.5s，只输出 5 个字符
                    -   %-10d 补空格后左对齐
                    -   %010d 补 0 后左对齐,%后面跟 0
                    -   %#x:十六进制和八进制输出添加 0x 或 0 等前缀
                    -   %lxxx:d o x u 格式字符，指定输出精度为 long，e f g 输出精度指定为 double
    -   scanf 接收用户输入
        -   int scanf(const char \*format,&变量地址)
            -   修饰符与 printf 类似，不能有提示信息，并且后面的是变量地址
            -   scanf("%d,%f",&i,&f) :动态输入
            -   scanf %s 不建议使用，不能缺点储存空间大小
            -   scanf 放在循环结构中要注意能否接收到有效值
            -   输入是出现分割符号,后面的都无法输出了 W

-   字符输入输出函数 getchar、putchar
    -   getchar 接收用户输入
    -   putchar 显示打印出字符
-   字符串输入输出函数 gets(!) 、puts
    -   gets 接收用户输入字符串，不建议用，可以用 fgets 代替
        -   gets 储存数据内存空间有指定的固定大小的，但是用户输入无限制，空间越界用户
    -   puts 输出

### 进制

-   十转二
    -   除二(16,除 8)取余数，倒数
-   Bxx、0xxx、0xFFF,B O Ox 前缀分别代表二进制八进制和十六进制
-   整型数据已补码相似储存
    -   正数补码就是他二进制本身
    -   负数补码是它绝对值的二进制-- 取反 -- +1
-   [源码反码](https://blog.csdn.net/MISSXIAOJJ/article/details/107425401)

```
23
十进制转二进制
不断除以2，从下往上取余

二进制
0001 0111  (有八位)

一个二进制为一位(Byte)
八位 为 一个字节(b)
1KB = 1024个字节(b)
1MB = 1024KB
....



二转八进制
三个二进制表示一个八进制
010 111
2     7
对应   4 2 1 等于7
4 2 1 通过2的次方得到的

二转十六进制
四个二进制表示7一个十六进制
0001 0111
1       7

二进制转十进制
0b10111
32 16 8 4 2 1
1*1 + 1*2 +1*4 + 0*8 + 1*16  = 23
```

### 流程控制

#### 顺序

-   语句逐行执行

#### 选择

-   if-else

```c
if(a = 1){
    cmd1;
} else {
    cmd2
}

# else 与最近的if匹配，嵌套的if-else中也一样，所以多行的话尽量写上大括号，除非只有一行
```

-   switch-case

```c
switch(exp){
    case 常量或常量表达式: printf('语句主体'); break;
    case 1: printf('a=1'); break;
    case 2: printf('a=2'); break;
    case 3:
    case 4: printf('a=3或a=4'); break;
    default: printf('其他我预料不到的情况')
}
```

#### 循环

-   while

```c
while(bool){
    loop
}

# 条件成立 则 执行循环体，否则跳出不执行
# 最少执行次数为0
```

-   do-while

```c
do{
    loop
}while(exp)

# 执行循环体 再判断条件，成立继续循环体，否则跳出不执行
# 最少执行次数为1
```

-   for

```c
for(exp1,exp2,exp3){
    loop
}

# 执行表达式1，判断表达式2是否成立，如果不成立直接退出，成立执行loop，再走表达式3，继续验证表达式2，成立走loop,否则退出循环
# 最少执行次数为0

for(,exp2,){
    loop；
    i++...
}

# for 只是把for之前的初始化 和for之后的条件判断、循环体、变化语句，结构化了,结构在，就可以正常运行
# 是可以的，只是exp1,3什么都没做
# 将自增操作放到循环体中，自增完，执行表达式3,空不报错，会继续验证表达式2
```

-   if-goto
    
    > 无条件跳转，且不能跨函数，破坏程序结构，不建议使用

```c
xxxxx
tag:
xxxxx
xxxxx
xxxxx
goto tag:
xxxxx

```

#### 辅助控制关键字

-   break:跳出所在整个循环(for,while...),一层
-   continue:跳出本次循环，不执行 continue 后面的内容,进入自增后的下次循环

### 数组

#### 二维数组

> 数组:可以产生一个`相同类型`并且`连续`的内存空间地址

-   定义[可省略的存储类型] 数据类型 标识符[长度]
    -   int arr[3] = {1,2,3}
-   初始化
    -   不初始化:int arr[3];
    -   半初始化:int arr[3] = {1}
    -   全初始化:int arr[3] = {1,2,3}
-   元素引用
    -   标识符[下标]
    -   下标:0 - (len - 1)
-   数组名[表示地址的一个常量]`本身就是一个地址 scanf等需要地址符号的地方不需要&`
    -   数组名：起始位置，声明后不能直接被赋值
    -   起始位置就是第一个元素的位置
-   数组越界
    -   一个三元素整型数组，假设当前环境，一个整型占四个自己，那么数组占用 1-12 的空间地址，如果再操作 arr[3] 第四个元素，使用 13-16 所在空间，这就产生数组越界
    -   数组越界程序无法判断为语法错误，需要自己注意

#### 二维数组

-   定义,初始化[可省略储存类型] 数据类型 标识符[行下标][列下标]
    -   arr[M][n] ，M 行，N 列，下标位置 arr[0][0] 到 arr[M-1][n-1]
    -   初始化：arr[M][n] = {{00,01,02},{10,11,12}}
    -   初始化：arr[M][n] = {{00},{10,11}} ;未初始化默认为 0
    -   初始化：arr[M][n] = {1,2,3,4,5,6} ;按内存顺序复制，不能跳过
    -   M 行号可以省略，根据列和值的个数自动计算行号
    -   地址与一维数组一样
-   元素引用
    -   arr[1][1]
-   储存形式
    -   顺序储存，按行储存
-   深入理解二维数组
    -   arr[2][3] ==> 看成:[[00,01,02],[10,11,12]]
    -   多维数组以此类推:arr[2][3][4] arr[00],是一个四元素数组
    -   arr+1,不是跳转一个元素自己大小，而是一行元素字节大小
-   练习题
    -   行列互换
    -   求二维数组的最大值，以及所在位置
    -   求各行与各列的和

#### 字符数组

-   定义，初始化
    -   [可省略的存储类型] 数据类型 标识符[长度]
    -   单字符初始化:char arr[3] = {'a','b,'c'}
    -   字符串常量初始化:
-   存储特点
    -   主要与普通数组差别最后会有一个尾 0`\0`作为结束标记

#### 字符串常用函数

> 引入头文件 string.h

char str[32] = 'hello'
char str2[32] = 'hello\0word'

-   puts(arr):输出
-   `strlen` 与 `sizeof`
    -   `strlen`：计算以`\0`结束的字符串长度(不包括尾 0)
        -   strlen(str):结果为 5
        -   strlen(str2):结果为 5 ,以尾 0 作为结束标识符
    -   `sizeof`:查看 str 占用的内存大小
        -   sizeof(str):结果为 6 ，去了六个字节
        -   sizeof(str2):结果为 11
-   字符串数组重新赋值
    -   str = 'abcde'; 是错误的
    -   strcopy(str,'abcde')；需要保证 copy 的串不能超过 str 定义的字节大小,否则`产生越界`
    -   strncopy(str,'abcde',32[size,防止越界])；无论 copy 的串多大，我只要参数三的大小
-   连接
    -   strcat(str," "):str 后连接上一个空格，覆盖 str 的尾 0，并添加一个新的尾 0，`注意大小，防止越界`
    -   strncat(str," ",SIZE):从参数二取最大 SIZE 个字节，追加到参数一的后面，没有 SIZE 个字节就取到尾 0 为止
-   比较
    -   strcmp(str,str2)
        -   通过 ASCII 比较，逐个字符比较
            -   相同:0
            -   参数一大:正值
            -   参数一小:负值
    -   strncmp(str,str2,5):只比较前五个
-   练习
    -   计算一个串中单词个数

### 指针

> 指针就是具有指向作用的地址，单独空间 A 地址不能认为是指针，而是要空间 B 储存的空间 A 地址才叫指针，这个 B 中储存的地址可以让 B 通过它获取另外一个地方的值

#### 变量与地址

-   变量
    -   对内存一块一块空间抽象命名(给我们看的,称呼，别名)
-   地址
    -   地址是内存中一块空间的编号,地址等价于指针，指向一块空间
    -   如:林锦天城.10 号是永辉超市
        -   xxx.10 号就是地址
        -   永辉超市这个名称就是变量
        -   倒闭了我接手,改名永辉大超市后，变量名发生了改变，但是地址是不变的
-   表达式的\*：取值的作用

指针案例 1

```c
int i = 1; // 给值为1的一个内存空间命名为i(生成地址 0x1000)
int *p; // 通过`int *`，定义一个命名为p准备作为的`一级指针变量`的空间(0x1001)
        // p是第一个保存`0x1000`这个地址的变量，也可以叫一级指针变量，`0x1000`这个具有指向作用的地址就是指针
        // 把指针指向a,a = &i，把指针指向p，就是p=&i;(如果有定义 int *a 的话)
p = &i; // 将i表示的那个空间地址`0x1000`赋值给p，也就是让p指向i，0x1001存着0x1000地址号


i = 1
&i = 0x1000
p = 0x1000  //
&p = 0x1001 //p这块储存0x1000
*p = 1 //*p ->*(0x1000) :去p指向的地址0x1000中取值(不是p自己的地址)
```

指针案例 2

```c
int i = 1; // 给值为1的一个内存空间命名为i(生成地址 0x1000)
int *p; // 通过`int *`，定义一个命名为p准备作为的`一级指针变量`的空间(0x1001)
        // p是第一个保存`0x1000`这个地址的变量，也可以叫一级指针变量，`0x1000`这个具有指向作用的地址就是指针
        // 把指针指向a,a = &i，把指针指向p，就是p=&i;(如果有定义 int *a 的话)
p = &i; // 将i表示的那个空间地址`0x1000`赋值给p，也就是让p指向i，0x1001存着0x1000地址号

int **q; //通过`int **` 定义一个命名为q，准备作为`二级指针变量`的空间(0x1002)
q = &p; //将P的地址`0x1001`赋值给了q



i = 1
&i = 0x1000
p = 0x1000  //
&p = 0x1001 //p这块储存0x1000
*p = 1 //*p ->*(0x1000) :去p指向的地址0x1000中取值(不是p自己的地址)

q = 0x1001
&q = 0x1002
*q = *(0x1001) = 0x1000 //获取0x1001的值 也就是 0x1000
**q = *(*(0x1001)) = *(0x1000) = 1;

```

#### 指针与指针变量

-   指针具有指向作用的地址(或被指针变量储存起来，能通过它获取相应值的地址)
-   指针变量:储存指针地址的变量

#### 直接访问与间接访问

-   直接范围
    -   上例通过&i 访问
-   间接访问
    -   p | \*q

#### 空指针与野指针

-   空指针
    -   定义好，暂不知道什么使用用的情况
    -   int \*p=NULL; NULL 宏一般值为 0
        -   系统上 0 号空间不分配给任何进程
        -   操作\*p 就是乱操作 0 号空间，系统会报错
-   野指针
    -   某个指向不确定的指针，定义好没有指向空间，也没指向 NULL 的情况产生
    -   int \*p; 直接使用\*p, auto 的 int \*会产生一个随机值,直接将这个随机值当做地址使用，的情况之一
    -   空指针是为了防止野指针的产生

#### 空类型

-   void int \*p;可以与其他类型指针数据交换赋值
    -   不确定指令类型的时候使用
    -   百搭的指针类型

#### 定义与初始化的书写规则

-   int \*p; int\* p;都行

#### 指针运算

-   &：取地址
-   \*：取指向目标的值
-   关系运算:
-   ++/--

#### 指针与数组

-   指针与一维数组

```c
int arr[3] = {1,2,3}
// arr 等同于arr+0 的地址 也等同于 arr[0] 的地址
// arr+1 的地址等同于 arr[1]，加不是移动一个字节。而是移动数组类型元素所在字节的个数

int *p = arr;

// arr[i] == *(arr+i)[因为arr是地址，偏移i的地址] == *(p+i)[p指针变量，储存着指针地址] == p[i] == 1,2,3
// &arr[i] == arr+i == p+i == p[i] == 0xxxx
// arr 与 p 的区别:arr是数组名，一个表示地址的常量；p是一个变量，存放地址的变量
// 在p没有++/--偏移的使用 p和arr是一样的
// 搞清除p+1与p++的差别，前者p并没有变，只是去取下一个元素的值了，p++,是使p不指向arr，而是指向arr[1]


```

-   指针与二维数组

```c
// 二维数组arr[2][3],认为是两行三类，一维数组+1移动一个数组元素，行指针，二维数组arr+1，直接从arr[0][0],跳到arr[1][0],称为列指针
// arr[i][j]的值是，arr先移动i行，取值，在移动j列，取值: *(*(arr+i)+j)，地址相当于 *(arr+i)+j
// 如果直接int *p = arr;警告,p+i移动i个元素，arr+i是移动i行
```

-   指针与字符数组

```c
char str[] = "string";
char *p = str+3;

puts(str)
puts(p) //ing ，把p指向的地址开始依次输出到尾0结束
```

#### const 与指针

```c
/*
 * const int a //变量a常量化，在后面值不能更改，对比宏可以检测语法
 * int const a
 *
 * const int *p //常量指针，和下面int提前的没差别，如果普通指针指向const变量是会被修改的，所以需要用常量指针
 * int const *p //常量指针，指针指向的目标变量值不能改变，指向可以改变
 *
 * int *const p //指针常量，指针指向的目标变量值可以能变，指向不能改变，只能指向最开始指向的变量
 * const int *const p //指针常量又是常量指针,指针指向的目标变量值不能改变，指向也不能改变
 **/

```

#### 指针数组与数组指针

-   指针数组
    -   定义: [存储类型] 数据类型 \* 数组名[长度]
        -   int \_ arr[2] //每个 arr[i]都是一个指针，int \* = 1，
        -   char _argv[]：argv 是一个数组，数组中有若干个元素，每个元素都是 char _,值就是外部传参内容
-   数组指针
    -   定义：[存储类型] 数据类型 (\*指针名)[下标]=值
        -   int (*p)[3] -> int[3] *p
        -   正常情况下 int 的 p+1 需要移动 int 所占用的字节数
        -   int[3] 就是移动三个 int 所占用的字节大小。如果二维数组 arr[2][3]的 arr+1 就可以等于 p+1，其他概念个一维数组差不多了
        -   数组指针可以理解为，定义一个指针，这个指针是在某种大小的数组间移动，或设置指针移动做小单位是多少

#### 多级指针

### 函数

#### 函数的定义

-   数据类型 函数名(数据类型 形参名,数据类型 形参名 2){}
    -   返回值
        -   数据类型一般为函数 return xx，或 exit(xx)的类型
        -   `retrun`:结束当前函数，main 中结束就是程序结束
        -   main 函数的 return 的值可以在命令中 `echo $?` 查看，如果没有返回值，就返回里面最后一个函数的返回值
        -   一个进程的返回值是给它父进程看的，main 的父进程就是执行程序的 shell

-   函数名和数组名一样，可以代表函数地址
#### 函数的传参

-   值传递

```c
int print_value(int a,int b){
    printf("a=%d,b=%d",a,b)
}

int main(){
    int i = 3,j = 5;
    print_value(i,j)
}
```

-   地址传递

```c

int print_value(int *a,int *b){
    /*
     * 定义一个指针变量a，和指针变量b，分别存放&i和&j这两个具有指向作用的地址(指针)
     * *a:获取a指针变量储存指针指向的值
     * *a = *b:指针变量b存储指针指向的值，赋值给a储存指针指向的空间
     *
     * */
    int tmp;
    tmp = *a;
    *a = *b;
    *b = tmp;
}

int main(int argc,char *argv[])
{
    /*
     * argc：计数器，统计从终端传过来多少个参数
     * argv：是一个列表，保存命令中传递过来的参数，以字符指针数组形式储存
     *
     * 查看
     * printf("argc=%d\n",argc);
     * for(int ar=0;ar<argc;ar++)
     *      puts(argv[ar]);
     *
     **/

    int i = 3,j = 5;
    print_value(&i,&j);

    printf("i=%d,b=%d\n",i,j);

	return 0;
}
```

-   通过全局变量传参

#### 函数的调用

-   嵌套调用

-   递归调用
    -   嵌套调用的特例
    -   一个函数直接或间接调用自身

-   注意事项
    -   被调用函数需要写在当前函数(主调函数)的上方，或者在上方声明，才能正常调用
        -   函数申明:void 函数名(void);

#### 函数与数组
-   函数与一维数组
```c
int print_arr(int *p,int n){ //int *p 可以写成 int p[],在形参中[]相当于*，与定义一个数组是含义是不一样的
    // sizeof(p) 指针变量p储存的是数组a的起始位置地址

    for(int i=0;i<n;i++)
        printf("%d",*(p+i))
    printf('\n')

}

int main(){
    int a[] = {1,2,3,4,5}

    printf('%s:%d\n',__FUNCTION__,sizeof(a)); //main:20

    print_arr(a,sizeof(a)/sizeof(*a)) //需要传入数组长度，应为函数内部接收到的a只是数组起始地址
}
```

-   函数与二维数组
-   函数与字符数组
#### 函数与指针
-   指针函数
    -   返回值为为地址，用指针接收的函数,**与整型函数，空函数**意思一样
    -   定义:
        -   返回值类型 * 函数名(形参)
        -   int * fun(int a){ return 0xXXXXX }
-   函数指针
    -   指针指向的是函数，**整型指针，指针指向整型数，数组指针，指针指向一个数组**意思一样
    -   定义
        -   `类型 (*指针名) (形参)`
        -   `int (*p)(int,int);` p = add 指向相同类型的函数；add 是 int add(int a,int b){}
-   函数指针数组
    - 数组里存放的不是整型int，而是函数指针
    -   定义
        -   类型 (*数组名[下标])(形参)
        -   int (*arr[N])(int); 数组有N个元素，每个元素都是指向函数的指针
-   指向指针函数的函数指针数组
    -   函数指针数组的每个函数都是返回一个地址，都要通过指针来接收返回值
### 构造类型
-   结构体
    -   结构体的产生以及意义
        -   为一系列不数据类型，提供连续内存空间类型
        -   结构体是一个类似int的东西，不占用空间，不能拿来赋值给谁，只是描述指定结构体可以是怎样的数据
    -   类型描述
        ```c
        struct 结构体名{
            数据类型1 成员1；
            数据类型2 成员2；
            数据类型3 成员3；
            int age;
            char name[32];
            struct 已存在的机构体名 对应变量; 
            struct {} 对应变量;直接嵌套结构体 
        }
        
        //无名结构图，直接定义变量
        struct {
            int age,
            char name
        }a,b={20,liao},*p,...
        ```
        -   建议定义在main函数外
    -   嵌套定义

    -   定义变量，初始化以及成员引用
        -   结构体定义变量
        -   struct 结构体名 变量 = {1，2，3}
        -   变量.age=10;
        -   成员引用
            -   变量.age
            -   指针->成员名
    -   占用内存空间大小
        -   默认，地址对齐情况
            -   某一个数据类型在该结构体字节位置%该数据类型所占的字节数 == 0；不整除就向下移动，移动的字节空间，无法再使用
            -   比如求结构体 struct case {int a;char b;float c;char d} 所占字节数
                -   结束分配addr第0、1、2、3、4、5、6、7、8、9、10、11、12、13个字节位置,加上该环境int是四个字节
                -   0%sizeof(int) == 0,int a 占用0、1、2、3;下一个从4开始
                -   4%sizeof(char) == 0,char b 占用4；
                -   5%sizeof(float) != 0,下移
                -   6%sizeof(float) != 0,下移
                -   7%sizeof(float) != 0,下移;空闲3个，字节地址对齐
                -   8%sizeof(float) == 0,float c 占用8、9、10、11
                -   12%sizeof(char) == 0,char d 占用12，由于字节对齐，此处也会计算成4个字节 ，所以该结构体占用0-15共16个字节

                -   公式:addr%类型所占字节数，整除则存放，否则向下偏移
                -   如果int 8个字节，那么
                    -   该结构体第一步就是0%8，最终结果会是32个字节
        -   结构体禁用地址对齐
            -   struct case {xxxxx}__attribute__((packed))
-   小案例
```c
#include<stdio.h>
#include<stdlib.h>
#default NAMESIZE 32

struct student_st{
    int id;
    char name[NAMESIZE]; //name字符数组，变量.name直接是地址
    int math;
    int chinese;
}
void stu_set(struct student_st *p){
    p->id = 1;
    strncpy(p->name,"liao",NAMESIZE);
    p->math = 90;
    p->chinese = 100;
}

void stu_show(struct student_st *p){
    printf("%d,%s,%d,%d\n",p->id,p->name,p->math,p->chinese);
}

void stu_changename(){

}
int main {

    struct student_st stu;
    stu_set(&stu);
    stu_show(&stu);
    stu_changename(&stu);
    exit(0)
}
```

-   共用体
    -   产生以及意义
        -   多个成员,只能一个成员生效,相当于多个选项，但只能选择一个
        -   所占内存大小为最大的成员字节大小
    -   类型描述
        ```c
        union 共用体名{
            数据类型 成员1；
            数据类型 成员2；
            数据类型 成员n；
        }
        
        int main{
            union 共用体名 变量;
            union 共用体名 指针;
            变量.成员1 = xxxx;
            指针名->成员1 = xxx;
        }
        ```
    -   嵌套定义使用
    -   定义不同类型变量，初始化以及引用
        -   变量.成员
        -   指针->成员
    -   内存占用空间大小
    -   函数传参的问题(值，地址)
    -   位域
        -   需再学一遍
-   枚举
    -   定义
    ```c
    enum 枚举名称{
        成员1, 
        成员2,
        成员3,
        ....
    }
    int main{
        enum 枚举名称 变量 = 成员1；
        直接 成员1 当做全局变量使用
        // enum 成员为未赋值默认从0开始，变量最终为0；
        // 如果定义时成员1 = 10；后面的依次增加
    }
    ```

### 动态内存管理
> 手动管理内存空间  
> 相关函数malloc、ralloc、realloc、free (释放)  
> 一般程序运行结束会自动释放,但是类似linux服务器一般不关机的，会不断需要内存，某些条件下必须手动控制  
> 原则:谁申请谁释放 
 

#### malloc
> 传入一个需要的内存大小，返回指定字节大小连续的内存起始地址 void *


```c
int main{
    int *p = NULL;
    p = malloc(sizeof(int)) //需要int大小的字节数
    if(p==NULL){ //如果malloc失败
        exit(1)
    }
    //一些列操作
    *p =10
        
    free(p) //释放
    exit(0)
}
```


#### calloc

> 参数1指定几个成员，参数2每个成员需要的大小
> 申请n个成员指定大小的，连续内存空间返回void *
#### realloc
> 重新分配一个动态内存空间
> 参数1为malloc或calloc返回的指针，参数2重新分配的大小，在原来基础上将大小扩展到重新分配的大小
#### free
> 释放之前调用 calloc、malloc 或 realloc 所分配的内存空间。
> 指针free后，最好将它赋为NULL
> free后原来指向的地址还存在，对那块空间没有了引用的权限，若需要使用该指针可以给它重新分配内存
> free 释放的是指针指向的内存,指针是一个变量，只有程序结束时才被销毁,释放了内存空间后，原来指向这块空间的指针还存在，只不过现在指针指向的内容是无用的,未定义的
(重新学习P63与free后一半)
### 调试工具和调试技巧(gdb、make)

### 常用内置方法

-   `typeof(x)`:获取 x 的类型

### 关键字
-   `typedef`:为已有的数据类型改名
    -   typedef 已有数据类型 新类型名;(必须分号)
    -   typedef int INT;
    -   typedef int ARR[6] ---> ARR array  ---> int array[6] 
    -   typedef int FUNC(int) ---> 给int(int)int类型int参数的函数改名FUNC  ---> FUNC f 相当于 int f(int) 
    ```c
    typedef struct{
        int i;
        float f;
    }NODE,*NODET;
    //定义一个 结构体 别名叫 NODE,定义一个 结构体* 叫 NODET
    ```
    -   如果不同环境需要将int改成long，那么用typedef long INT；
### 常用库函数

-   man 函数名：就可以指定调用这个函数需要引入什么头文件

### 问题

-   连个函数名相同，参数不想听的函数，如何判断是用重载实现还是变参实现?
    -   调用是多传参数，编译报语法错误，那就是重载定参的
    -   如果编译不报错，使用才报错说明是变参实现的，函数本身都不知道需要多少参数

### 系统宏

-   **FUNCTION**:函数名
-   **LINE**:当前行号
