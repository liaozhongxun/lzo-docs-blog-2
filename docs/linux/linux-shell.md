---
title: shell
---

## shell 脚本

### 概述
- ls(命令) -> shell(bash、zsh) -> 内核(kemel) -> 硬件
    - `ls`:用户使用文字或图形界面操作操作系统
    - `shell`:接受与来自用户的命令与内核进行沟通，是`用户`与`内核沟通`的接口程序
    - `内核`:控制硬件进行工作，进程管理储存管理等
- shell对本质是`对内核进行保护`，只有`shell能识别`的命令才能用了操控硬件
- 脚本语言`不需要` 编译
- `shell脚本`是shell命令的`有序集合`
- `系统编程`:主要为了让用户更好更方便的操作硬件设备，并且对硬件也起到保护作用，我们所写的程序，本质就是对硬件进行操作，所以操作系统提供的接口本来就能对硬件进行操作的
- `系统调用`: 
    - 步骤: shell、library rou(库函数)、applications(应用层接口) -> system calls(系统调用，提供直接操作内核的特殊接口) -> kernel(内核) -> 操作硬件设备
    - 
### 开启 shell

```shell
#!/bin/bash   指定使用bash解释器,必须顶格
cat /etc/passwd
echo "hello word"

# ==================定义一个变量
num=10 #等号左右不能有空格
readonly age=20 #age不能被改变
export name="name" #name会被导出为环境变量,其他shell都能使用
declare -i sum # sum是一个整数变量

echo $num # 使用变量加$
echo ${num}Addstring # 使用变量加${}
# --- "" 弱引用 里面可以读取变量
# --- ``|$() 把里面的内容当中命令执行，得到执行返回的结果
oa="this is $num ，`date`,$(date)"
# --- '' 强引用 把动态的操作当成字符，

unset num #清除变量



# ==================if语句
#用do 和 down 表示其他语言的{}

if [ 1 ]
then
    echo "yes"
elif [ 2 ];then
    echo "noyes nono"
else
    echo "no"
fi  # 结束语句


# ================== case
read "请输入任意字符" key
case "$key" in
    [a-z]|[A-Z])
        echo "这是英文字母"
        ;;
    [0-9])
        echo "这是一个数字"
        ;;
    *)
        echo "这是一个其他字符"
esac


# ================== for 循环
for(( i=1; i<=100; i++ ))
do
    echo $i
done
# ================== for in
for i in 1 2 3 4 5
do
    echo $i
done

for i in 1 2 3 4 5
do
     echo $i &  #相当于多进程并发执行 ，适合耗时长，后面程序不依赖当前结果，且计算机资源足够的时候
     # 线程是进程的一部分，shell只能多进程，多线程需要Python的高级语言
     # 这边只适合一条语句，如果复杂可以放到函数里 funcName 12 &
done
wait # 等待循环体全部执行完再做后面事情
xxx
# 列表
# {1..5} 1-5
# $(ls /etc)

# ================================= while
i=1
while [ $i -le 100 ]
do
    echo $i
    i=$[$i + 1]
done

# 操作文件
while read line
do
    echo "${$line}-change"
done < /etc/passwd

# until
# 与while循环相反，测试成立才退出循环
i=1
until [ $i -le 100 ]
do
    echo $i
    i=$[$i + 1]
done
# ================================== 函数
function name { xxx }
name(){ 
   SUM=$[$1+$2]
   return SUM
}

name 1 2  # 通过位置变量接收参数
echo "$?" #获取返回值方式最大255
# 在shell中处理()中定义的变量，只要不做任何修饰，都能看做是全局变量


# ==================总结
# 指定解释器的地方
# 1、shell文件顶端；2、bash shell.sh；3、通过路径执行脚本的终端；
# 2、分号可以合并多行，或者一行执行多条命令
```

### 执行

-   echp $PATH
-   存放外部命令的路径
-   访问命令就可以省去前面的路径直接写名字
-   一个`shell脚本`可以看做一个命令
-   如果没在`$PATH`里的路径下,就需要`加上绝对路径`或`相对路径执行`才能执行,
-   或直接通过`/etc/shells`下的解释器直接执行脚本
-   `bash shells.sh` -`-n`:检查错误 -`-x`:将脚本中执行的命令也打印出来

### 语法
-  特殊符号
    - `\`:`echo -e "this \n towline"` 配合 -e 生效 
    - `(xxx)`:小括号会创建一个子shell，里面操作不会影响当前shell
    - `{xxx}`:大括号里的操作会音响当前shell
-   算术运算符(`+、-、*、/、%、**`)
    -   `$[$a+$b]`:运算+不能直接用,`$[]`或`$(())`或`expr 1 + 2`里的东西当做运算处理'
-   变量
    -   `普通变量`
    -   `环境变量`
        -   一般大写表示
        -   常用环境变量
            -   `$PATH`:用户命令路径
            -   `$SHELL`:用户使用的 shell
            -   `$HISTSIZE`:history 查看历史命令，这个可以查看 history 上限
            -   `$USER`:获取当前用户的名称
            -   `$HOME`:获取当前用户加
            -   `$PWD`:获取当前用户工作目录
            -   `$UID`:获取当前用户的 ID
            -   `$LANG`:语言
        -   临时更改: PATH = xxxx
        -   定义环境变量
            -   `export NAME="name"`:NAM 只有当前 shell 和子 shell 生效
            -   添加扩展PATH:export PATH="/home/tuotu/bin:$PATH"
            -   永久设置
                -   `bashrc`：用户登录、打开 shell、开子 shell 都会执行
                    -   `/etc/bashrc`
                    -   `~/.bashrc`
                -   `profile`:只在用户登录时执行一次
                    -   `/etc/profile`:全局
                    -   `/etc/profile.d/*.sh`:优先级高，所有符合条件的文件开机都会执行一次
                    -   `~/.bash_profile`:局部的
                -   `source|. filename`:都能重新加载文件
        - `env` 查看系统所有环境变量
    -   `位置变量$1-$9`:接收用户执行脚本的传参，超过9 `${10,...}`
    -   `预定于变量`
        -   `$?`:0:上一条命令执行结果为真,否则执行为假[ -z $1 ]
        -   `$#`:表示位置参数数量
        -   `$0`:当前脚本的名称
        -  `$@,$#`:保存除$0外的所有参数
        -  `$$`:获取当前进程的进程号
-   条件测试与比较 `[ 条件表达式 ]` | `test -d $1`
    -   解释
        -   `[ 条件表达式 ]`
        -   `[[ 条件表达式 ]]`:这种支持传统的大于小于号
        -   中括号两边必须存在空格
    -   检测
        -   `[ -d $1 ]`:检测参数一是否为目录
        -   `[ -f $1 ]`:检测参数一是否为文件
        -   `[ -e $1 ]`:检测母乳或文件是否存在
        -   `[ -r $1 ]`:
        -   `[ -x $1 ]`:
        -   `[ -w $1 ]`:检测用户是否有写入权限
        -   `[ -s $1 ]`:检测文件是否为空
        -  文件类型按ll第一位的文件类型检测    
    -   数值比较
        -   `-eq`:等于
        -   `-ne`:不等于
        -   `-gt`:大于
        -   `-lt`:小于
        -   `-le`:小于等于
        -   `-ge`:大于等于
    -   字符串比较
        -   `=`:等于
        -   `!=`:不等于
        -   `-z`:[ -z $1 ]检测字符串是否为空
        -   `-n`:[ -n $1 ]检测字符串是否不为空
        
        -   `在进行字符串比较时，最好为字符串加上引号，并且等号两侧留有空格`
    -   文件比较
        - `file1 -nt file2`:判断文件1修改时间是否比文件2新
        - `file1 -ot file2`:判断文件1修改时间是否比文件2旧
    -   逻辑运算
        -   `-a、-o、!`:类 1 
        -   `&&、||`:类 2 `链接两个命令` 有断路功能
-   循环控制语句
    -   `break`:结束退出循环
    -   `continue`:跳出本次循，不执行 continue 本次循环内后面的代码
-   其他
    -   `shift`:删除第一格位置参数,后面如果有全部往左移动一格
    -   `exit`:直接退出程序
        `exit 1-255`:程序结束后返回值，通过`$?`获取，程序正常结束值为 0

### 命令[ -z $1 ]

-   `read num` : 暂停获取用户输入信息
    -   `-p 请输入一个数字`:增加提示
-   `seq`:构造列表
    -   数量
        -   `seq 5`:尾数
        -   `seq 5 6`:首数 尾数
        -   `seq 1 2 10`:首数 增量 尾数
    -   选项
        `-w`:补 0 到最大位数
-   `cut`:取列值（类似数组切割 splic）
    -   `-d':' -f3`:将一行通过:分割，并获取第三段
    -   `-f1,5`:选取多列
    -   `-f1-5`:选取多列
-   `bash`: 执行脚本
    -   `-n`:测试语法错误
-   `sort`:对文本`输出结果`进行排序，不影响源文件
    -   默认以首字母 ASCII 进行排序
    -   `man ascii`:查看 ASCII 表
    -   选项
        -   `-r`:降序
        -   `-t":" -k3`:指定分割符号，并安装指定`列`进行排序
        -   `-n`:按照数值大小排序，需明确对象是数字
        -   `f`:忽略大小写
        -   `u`:去除重复
-   `uniq -c`:统计`连续`相同的个数，配合 sort 使用
-   `tr`:单字符对应替换

    -   `tr ab 12`:将文本所以 a 替换成 1，所以 b 替换成 2
    -   `tr -d " "`:不指定目标字符，删除操作

-   文本处理三剑客
    -   `grep`:查找
    -   `sed`:查找、替换
        -   格式: `sed [选项] 'sed脚本' 文本文件`
            -   多选项 -i -E 分开
        -   选项
            -   `-r`:使用扩展正则
            -   `-i`:直接编辑文本
            -   `-e`:多点编辑
            -   `-n`:不输出模式空间内容,配合`p`使用
            -   `-f` ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；
        -   脚本（在`哪个位置`做`某个事情`）
            -   /可以用#代替,都行
            -   地址定界
                -   1、不指定地址,s默认全文编辑
                -   2、单地址:`num`表示第几行,`$`表示最后一行
                -   3、`/PATTERN/`:表示被次模式匹配到的行，可以是正则
                -   4、地址范围:`num,num`表示从第几行`到`第几行，`num,+num`表示从第几行`向下`几行
                -   5、步进:`num~num`从地几行开始，每几行
            -   编辑命令
                -   `a`:新增 表示在指定行之后追加内容
                -   `d`:删除
                -   `c`:取代|修改 表示将指定行替换成新的内容
                -   `p`:打印 输出模式空间被匹配到的内容
                -   `i`:插入 在指定行之前插入
                -   `w filename`:将指定内容另存为新的文件
                -   `r filename`:读取某文件内容到指定行之后
                -   `!`:取反

                -   `s`:`s/旧内容/新内容/替换选项`,替换指定字符(存在/的内容可以用\转意或使用s#old#new#option)
                    -   替换选项
                        - `g`:全局，每行所有匹配都替换
                        - `p`:只输出操作的内容，与`-n`配合，控制台只能看懂操作过的行
                        - `n`:（1-512），每行第n个匹配替换
                        - `w <file-name>`: 将匹配修改的结果写入指定文件中
                    - `&`:将`规则匹配到`的字符`拼接上`指定字符，&符号代表匹配到的字符串
                      - `sed 's/r..t/bf&er/g' /etc/passwd` :将r两字符d的，前面加上bf后面加上er
        -   示范
            -   `sed '10d' /etc/fstab`:删除 fstab 文件`输出内容`的第十行
                -   `10!d`:不删除第十行
                -   `1,3d`:删除 1 到 3 行
                -   `d`:删除所以输出内容
                -   `/^UUID/d`:删除一 UUID 开头的`行`,两个`/`是地址定界符
                -   `5r filename`:文件内容读取到 fstab 第五行后面
            -  多点编辑
                - 删除文件第三行后面的数据，并将bash替换成aaa
                - `sed -e '3,$d' -e 's/bash/aaa/' /etc/fstab`
            - s替换
                - 1到十行开头添加#
                - `sed '1,10s/^/#/g' /etc/fstab`

            - 操作管道内容
                - `cat /etc/fstab| sed xxxx`
            - 不要默认输出，只要有操作的行输出
                -   `sed -r -n '5s/[a-w]+/&_addstr/p' filename`
            -   批量替换文件内容
                -   `sed`:[sed -i "s#https#http#g" `grep http -rl VERO`] 将 VERO 下所有子目录所有文件里的 http 替换成 https
    -   `awk`:是GNU的开源awk，实际叫做`gawk`
        -   概念
            - awk是一种进程的轻量级语言，他有自己的变量，自己的一些语句，`不是shell`的语法
            -   awk中,横行(record)，NR指number record横行数量
            -   竖行(field)，NF值number field，竖行分段数量
        - 格式: `awk [选项] 'pattern|范围 {action动作}' file`
        - 选项：
            - `-F":"`:指定pring分隔符，默认空格或制表符，符号可以是正则表达式
        - 范围:
            - `'/^reg/{xxxxx}'`:可以是正则
            - `'$3>=500{}'`
            - `'RN==3{}'`
        - 模式(pattern)：定义变量等

        - 动作：
            - `print`:输出
            -   默认分割付空格，`$1,$2`：逗号分开，打印的时候是用空格分开的

        - 变量 
            - `NF`:分割符分隔之后的字段数量, {print $NF}代表获取最后一个字段
                -   `print $NF`:打印最后一段
            - `NR`:行号
                - `awk 'RN==3{print $1}' file`
                - `awk 'RN>=3&&RN<=5{print $1}' file`
            -   `FILENAME`:文件名称
            -   `OFS="#"{}`:指定输出字段的分割付
            
            -   全局变设置 BEGIN{xxx;xxx2}
                -   `FS`:`BEGIN{FS=":"}`,通过全局变量设置默认输入分割付为分号
                -   `OFS`:设置默认输出分隔符

        - 功能
            - 截取字段
                -  `awk '{print $1,"拼接格式",$2}'`:以空格或制表符切割，`$1-$n`代表每一个分段，`$0`整行
            - 运算
                - `echo "2 3 4"|awk '{print $1*$2-$3}'`:2
            - BEGIN 和 END
                - `awk 'BEGIN{print "所有行正文之前插入"}{print $0,"正文"}END{print "所有处理结束"}'`

        -   使用
            -   awk '{print $1 "\t" $2} filename':打印每行第2，3个段，默认空白符号分割,\t对齐
            -   awk -F":" '$3==102&&$4=="bold"&&NF==7{print $0}' filename:
                -   输出第三列是102,并且第四列为bold,并且是七列的行
            -   awk -F":" '$3==102{$5="***";print $0}' filename
                -   隐藏第五列的内容
            
            -   awk -F":" '/^abc/{print $0}' filename:通过正则验证    
    -   ag(the_silver_searcher)
        -   `ag -l 关键字 dir`：查找dir文件夹下所以包含指定关键字的文件名

## 系统调用
### IO操作

- 文件描述符
    - 文件描述符是非负整数,打开现存文件或新建文件时，系统内核会返回一个描述符来指以打开的文件
    - 在系统调用(文件IO)中,文件描述符起到标识作用，操作文件，就是对描述符号的操作
    - 程序运行或进程开启，系统自动创建三个描述符
        - `0 标准输入` -> 标准IO `stdin`
        - `1 标准输出` -> 标准IO `stdout`
        - `2 标准错误` -> 标准IO `stderr`
    - 创建文件描述符
        - int open('filename.txt',文件标志)
        - int open('filename.txt',文件标志(存在O_CREAT),权限)
